2018/10/22

一、创建型（Creational）

1. 工厂方法（Factory Method）

【定义】：定义一个创建对象的接口，让实现这个接口的类来进行具体的实例化；工厂方法让类的实例化推迟到子类中进行。

【适用场景】：

- 创建对象需要大量重复的代码
- 客户端（应用层）不依赖于产品类实例如何被创建、实现等细节
- 一个类通过其子类来指定创建哪个对象（多态创建对象）

【优点】：

* 用户只需关心所需产品对应的工厂，无需关心创建细节

- 加入新产品符合开闭原则（对扩展开放对修改关闭），提高可扩展性

【缺点】：

- 类的个数容易过多，增加复杂度
- 增加了系统的抽象性和理解难度



2. 抽象工厂（Abstract Factory）

【名词解释】：产品族和产品等级结构

如果电器看成一个产品，那么同一家公司生产的所有电器就是一个产品族，不同公司生产的同类产品就属于同一个产品等级结构。例如：美的生产的空调、冰箱、洗衣机就是一个产品族，美的生产的冰箱、海尔生产的冰箱、松下生产的冰箱就属于同一产品等级。

工厂方法侧重产品等级结构，抽象工厂侧重产品族。

【定义】：抽象工厂提供创建一系列相关或相互依赖的产品对象的接口，无需指定它们具体的类。

【适用场景】：

- 客户端（应用层）不依赖于产品类实例如何被创建、实现等细节
- 强调一系列相关的产品对象（属于同一产品族）一起使用创建对象需要大量重复的代码
- 提供一个产品族的库，所有的产品使用相同接口进行实例化，从而使客户端（应用层）不依赖于具体产品的实例化。

【优点】：

- 具体产品在应用层代码隔离，无需关心创建细节（所有创建型设计模式共有的优点）
- 将一系列产品族的产品统一到一起创建

【缺点】：

- 由于一开始就规定了所有可能被创建的产品集合，这就造成在产品族中扩展新产品的困难，即在产品族中新增一类产品需要修改抽象工厂的接口（违背了开闭原则）。
- 增加了系统的抽象性和理解难度



3. 建造者（Builder）

【定义】：将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。用户只需指定需要建造的类型就可以得到它们，建造过程及细节不需要知道。

【适用场景】：一个产品对象有非常复杂的内部结构（很多属性），并且希望把复杂对象的创建和使用进行分离。

【优点】：

- 封装性好，创建和使用分离
- 扩展型号，建造类之间独立，一定程度上解耦

【缺点】：

- 会产生多余的Builder对象
- 如果产品内部发生变化（属性数量、类型发生更改），建造者需要修改，成本较大

【注意】：建造者和工厂模式（简单工厂、工厂方法和抽象工厂）很接近，比较明显的区别是：首先，建造者模式强调方法的调用顺序，方法的调用顺序不同可能创建的对象也就不同，而工厂模式不在乎方法的调用顺序；其次，创建粒度不同，一般来说建造者模式创建的对象更复杂；最后，关注点不同，工厂模式只关心最终对象是否被成功创建，而建造者模式不止要创建出对象，还要明确对象是由哪些元部件组成的。



4. 单例（Singleton）

【定义】：保证一个类有且仅有一个实例，并提供一个全局访问点。

【优点】：

- 在内存里只有一个实例，减少了内存开销
- 设置了全局访问点，严格控制访问，提高了安全性

【缺点】：

- 不向外提供接口，扩展困难

【核心 / 重点】：

- 私有构造器
- 线程安全
- 延迟加载（懒加载）
- 序列化和反序列化安全
- 反射（防御反射攻击）

【注意】：

- 不管哪种写法实现单例，必须有且仅有一个私有构造器。